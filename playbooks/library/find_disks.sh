#!/bin/bash
#
# (c) 2017 MapR Technologies, Inc. All Rights Reserved.
#
# Begin autogenerated shell template

if [ -n "$DEBUG" ] && [ "$DEBUG" -eq 1 ]; then
    set -x
    exec 2> /tmp/do_cfg_$$.out
fi

SED_EXP="s/\s?\([^=]+\)\s?=\s?\(\x22\([^\x22]+\)\x22|\x27\([^\x27]+\)\x27|\(\S+\)\)\s?/\1='\2'/p"
[ -n "${1}"  -a  -f "${1}" ] && eval $(sed -e ${SED_EXP} $1)

function exit_change() {
    exit_helper "\"changed\":true, " "$@"
}

function exit_no_change() {
    exit_helper "\"changed\":false, " "$@"
}

function exit_fail() {
    exit_helper "\"failed\":true, " "$@"
}

function exit_helper() {
    [ -n "${LOGLINES}" ] && log_lines=", \"mapr_logs\":\"${LOGLINES}\""
    echo "{ $1 \"msg\":\"$2\" ${log_lines} }"
    exit 0
}

function LOG() {
    local msg="$@"
    [ "INFO" != "$1" -a "ERROR" != "$1" -a "WARN" != "$1" ] && msg="INFO $@"
    local print_var="$(date +"%F %T %Z") $LOG_LEVEL $(echo "$msg"|tr '\n' ' '|tr '\r' ' '|tr '\"' ' '|tr "\'" ' '|tr '\000-\037' ' ')"
    [ -n "${LOGLINES}" ] && print_var="${LOGLINES}\n${print_var}"
    printf -v LOGLINES "%s" "${print_var}"
}

function LOG_ERROR() {
    LOG "ERROR" "$@"
}

function LOG_INFO() {
    LOG "INFO" "$@"
}

function LOG_WARN() {
    LOG "WARN" "$@"
}

function LOG_RUN_CMD() {
    local cmdstr="$(echo "$@" | cut -d' ' -f1)"
    run_cmd "$@"
    show_cmd_res "$@"
    echo "$@" | grep -q "timeout -s HUP" && check_timeout "$cmdstr" $CMD_RET
}

function run_cmd() {
    local cmd="$@"
    CMD_RES="$(eval $cmd 2>&1)"
    CMD_RET=$?
}

function show_cmd_res() {
    local msg="Command: $@, Status: ${CMD_RET}, Result: ${CMD_RES}"
    [ $CMD_RET -eq 0 ] && LOG_INFO $msg  || LOG_ERROR $msg
}

function exit_with_cmd_ret() {
    local ret=$1
    [ -z "$ret" ] && ret=$CMD_RET
    local script_name="$(basename $0)"
    [ $ret -eq 0 ] && exit_change "${script_name} passed" || exit_fail "${script_name} failed"
}

function run_with_retry() {
    RETRY_SLEEP=${RETRY_SLEEP:-1}
    RETRY_TOTAL=${RETRY_TOTAL:-1}
    local rem_time=$RETRY_TOTAL
    while [ $rem_time -gt 0 ] ; do
        run_cmd "$@"
        [ $CMD_RET -eq 0 ] && break
        sleep $RETRY_SLEEP
        rem_time=$[rem_time - $RETRY_SLEEP]
    done
    show_cmd_res "$@"
    [ $CMD_RET -ne 0 ] && LOG_ERROR "command failed after waiting ${RETRY_TOTAL} seconds, sleeping ${RETRY_SLEEP} seconds between each retry"
}

function get_timeout() {
    local val
    [ -n "$1" ] && val="$1" || val="2"
    local unit
    [ -n "$2" ] && unit="$2" || unit="m"
    type timeout > /dev/null 2>&1 && TIMEOUT="timeout -s HUP ${val}${unit}" || LOG_WARN "timeout cmd not found"
}

function check_timeout() {
    local retval
    local cmdstr=""
    [ -n "$1" ] && cmdstr="($1)"
    [ -n "$2" ] && retval=$2 || retval=$?
    [ $retval -eq 124 ] && LOG_WARN $1 "Command${cmdstr} timed out "
}

[ $(id -u) -ne 0 ] && SUDO="sudo"

LOG "Running $(basename $0)"
# End autogenerated shell template
function remove_from_fstab() {
    mnt=${1}
    [ -z "${mnt}" ] && return

    FSTAB=/etc/fstab
    [ ! -w $FSTAB ] && return

    # BE VERY CAREFUL with sedOpt here ... tabs and spaces are included
    sedOpt="/[ 	]"$(echo "$mnt" | sed -e 's/\//\\\\\//g')"[ 	]/d"
    sed -i.mapr_save "$sedOpt" $FSTAB
    [ $? -ne 0 ] && LOG_ERROR "failed to remove $mnt from $FSTAB"
}

function unmount_unused() {
    [ -z "${1}" ] && return
    LOG "Unmounting filesystems ($1)"
    fsToUnmount=${1:-}#!

    for fs in $(echo ${fsToUnmount//,/ })
    do
        LOG_RUN_CMD fuser $fs
        if [ $CMD_RET -ne 0 ] ; then
            LOG "$fs is not in use. Preparing to unmount ..."
            umount $fs 2> /dev/null
            remove_from_fstab $fs
        else
            pids=$(echo $CMD_RES | cut -d' ' -f5-)
            LOG "$fs is in use by these process ids: $pids"
            for pid in $pids
            do
                LOG_RUN_CMD ps --no-headers -p $pid
            done
        fi
    done
}

# Use fdisk to check for available disk spindles.
#	Advantages: fdisk seems to be on all Linux Distros
#	Disadvantages: fdisk can only be run as root.
find_mapr_disks() {
    disks=""
    for d in $(fdisk -l 2>/dev/null | grep -e "^Disk .* bytes" | awk '{print $2}')
    do
        dev=${d%:}
        LOG_RUN_CMD cfdisk -P s $dev &> /dev/null
        [ $CMD_RET -eq 0 ] && continue
        LOG_RUN_CMD mount | grep -q -w -e $dev -e ${dev}1 -e ${dev}2
        [ $CMD_RET -eq 0 ] && continue
        LOG_RUN_CMD swapon -s | grep -q -w $dev
        [ $CMD_RET -eq 0 ] && continue
        if which readlink &> /dev/null ; then
            realdev=$(readlink -f $dev)
            LOG_RUN_CMD swapon -s | grep -q -w $realdev
            [ $CMD_RET -eq 0 ] && continue
        fi

        if which pvdisplay &> /dev/null ; then
            LOG_RUN_CMD pvdisplay $dev &> /dev/null
            [ $CMD_RET -eq 0 ] && continue
        fi
        disks="$disks $dev"
    done
    # Strip off leading space
    MAPR_DISKS="${disks# }"
    export MAPR_DISKS
}

# For Amazon instances, we can ditch the "/mnt" and /media/ephemeral
# directories if they are not in use.  Do this before find_mapr_disks
# operation.
unmount_unused /mnt
if [ -d /media/ephemeral0 ] ; then
    for d in /media/ephemeral? ; do
        unmount_unused $d
    done
fi

if [ -n "${DISKFILE}" ] ; then
    find_mapr_disks
    for d in $MAPR_DISKS ; do
        echo $d >> $DISKFILE
    done
    exit_change "MapR DISKFILE ${DISKFILE} created with ${MAPR_DISKS// /,}"
else
    exit_fail "MapR DISKFILE not provided"
fi
